<html>

<!--
Compatibility notes :
* input type range : IE11+ (http://caniuse.com/#feat=input-range)
-->

<head>
	<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-hQpvDQiCJaD2H465dQfA717v7lu5qHWtDbWNPvaTJ0ID5xnPUlVXnKzq7b8YUkbN" crossorigin="anonymous">
	<script   src="https://code.jquery.com/jquery-2.2.3.min.js"   integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo="   crossorigin="anonymous"></script>
	<script src="webpd.js"></script>

	<style>
	.field{
		vertical-align: top;
	}
	.field label{
		vertical-align: top;
		display:inline-block; 
		width:220px;
		padding-top: 4px;
	}
	.field input{
		vertical-align: top;
		display:inline-block;
	}
	#panelDetails{
		padding: 15px;
	}
	#panelDetails div.field{
		padding-top: 5px;
		padding-bottom: 5px;
		border-bottom: 1px solid #777;
	}
	</style>
</head>

<body style="background-color: 0; margin: 0; padding: 0; font-family: Verdana; font-size: 10px">

<div style="position: fixed; top: 0; right: 0; opacity: 0.9; background-color: 0; color: #fff">
	<div>
		<button id="btShowHideDetails" class="fa fa-gears fa-4x" style="float: left;"></button>
		<label id="panelTitle" style=" display: none; font-size: 4em; padding-left: 2em">I am A-STAR</label>
	</div>
	<div id="panelDetails" style="display: none; clear: left;">
		<div class="field">
			<i class="fa fa-clock-o fa-2x"></i>
			<label>Want to change my brain speed ?</label>
			<input id="timeSlider" type="range" min="1" max="50" value="10">
		</div>
		<div class="field">
			<i class="fa fa-comment-o fa-2x"></i>
			<label>Want to know what i'm thinking ?</label>
			<input id="optAITalkings" type="checkbox">
		</div>
		<div class="field">
			<i class="fa fa-commenting-o fa-2x"></i>
			<label>Want to know what i'm really thinking ?</label>
			<input id="optAIFunnyTalkings" type="checkbox">
		</div>
		<div class="field">
			<i class="fa fa-th fa-2x"></i>
			<label>Want to change my environement ?</label>
			<input id="sizeSlider" type="range" min="4" max="100" value="30">
		</div>
		<div class="field">
			<i class="fa fa-hand-stop-o fa-2x"></i>
			<label>Want to take over ?</label>
			<button id="btNextStep" class="fa fa-step-forward fa-2x"></button>
			<button id="btPlay" class="fa fa-play-circle fa-2x"></button>
			<button id="btNext" class="fa fa-fast-forward fa-2x"></button>
		</div>
		<div class="field">
			<i class="fa fa-map-o fa-2x"></i>
			<label>I lost you ?</label>
			<button id="btResetTransform" class="fa fa-arrows-alt fa-2x"></button>
		</div>
		<div class="field">
			<i class="fa fa-music fa-2x"></i>
			<label>Want to hear me ?</label>
			<input id="optSound" type="checkbox" checked>
		</div>
		<div class="field">
			<i class="fa fa-eye fa-2x"></i>
			<label>Want me to show more ?</label>
			<input id="optPathPersistence" type="checkbox">
			<i class="fa fa-road fa-2x"></i>
		</div>
		<div class="field">
			<i class="fa fa-cloud fa-2x"></i>
			<label>Want more ?</label>
			Maybe one day ...
		</div>
		<div class="field">
			<i class="fa fa-bug fa-2x"></i>
			<label>Want to see under the hood ?</label>
			<input id="optShowDistance" type="checkbox">
			<i class="fa fa-calculator fa-2x"></i>
		</div>
	</div>
</div>

<canvas id="canvas" width="100" height="100" draggable="false" onmousemove="canvasDrag(event)"></canvas>
<script>

AIThoughts = [
	"Do you really undertand why I'm doing this ? Cause I'm not.",
	"I Know, it looks like a cross-words map, but it's not.",
	"Do you even look at what I'm sayin ?",
	"I'm pretty confident on this one !",
	"I'm a little tired doing this, but who cares ?",
	"Are you an AI ? cause I'm wondering if I am too !",
	"You know you can tweak me, right?",
	"This is the A-STAR Algorithm, does it make me a star ?",
	"Do you get I can say weird thing or not ?"
]


$.get('astar.pd', function(patchStr) {
  patch = Pd.loadPatch(patchStr)
  Pd.start()
})

$('#sizeSlider').on('change', function () {
	cancelPathFinding()
	gridHeight = this.value
	gridWidth = Math.floor(window.innerWidth * gridHeight / window.innerHeight)
	createGraph()
    resizeCanvas()
});


$('#btResetTransform').on('click', function () {
    ofx = ofy = 0
    resizeCanvas()
    drawStuff()
});

$('#btShowHideDetails').on('click', function () {
    $('#panelDetails').css('display', $('#panelDetails').css('display') == 'block' ? 'none' : 'block');
    $('#panelTitle').css('display', $('#panelTitle').css('display') == 'block' ? 'none' : 'block');
});

var optPathPersistence = false

$('#optPathPersistence').on('change', function () {
    optPathPersistence = this.checked
    drawStuff()
});

var optShowDistance = false

$('#optShowDistance').on('change', function () {
    optShowDistance = this.checked
    drawStuff()
});

var optAITalkings = false

$('#optAITalkings').on('change', function () {
    optAITalkings = this.checked
    drawStuff()
});

var optAIFunnyTalkings = false

$('#optAIFunnyTalkings').on('change', function () {
    optAIFunnyTalkings = this.checked
    drawStuff()
});

$('#optSound').on('change', function () {
    if(this.checked)
    	Pd.start()
    else
    	Pd.stop()
});

var optAutoStepping = true

$('#btNextStep').on('click', function () {
	if(playing)
	{
		if(optAutoStepping)
		{
			optAutoStepping = false
		}
		else
		{
			startASTAR()
		}
	}
	else
	{
		optAutoStepping = false
		init()
	}
   
});

$('#btPlay').on('click', function () {
    
    if(playing && !optAutoStepping)
    {
    	optAutoStepping = true
    	startASTAR()
    }
    else if(!playing)
    {
    	init()
    }
    
});

$('#btNext').on('click', function () {
    // cancelPathFinding()
	init()
});

$(function() {
	gridHeight = 30
	gridWidth = Math.floor(window.innerWidth * gridHeight / window.innerHeight)

	createGraph()
	resizeCanvas();
	if(AUTO_PLAY)
	{
		init()
	}
	
});

function pd_event(name){
	
	if(head)
	{
		Pd.send("pan", [head.x / gridWidth])
	}
	else
	{
		Pd.send("pan", [0.5])
	}
	// Pd.send(name, [500 / timeSlider.value])
	Pd.send(name, [500 / timeSlider.value])
}

function pd_free(freq, duration){
	
	Pd.send("pan", [0.5])
	Pd.send("free", [duration / timeSlider.value, freq])
}

function soundFromDistance(node, freq_min, freq_max, duration)
{
	dx = src.x - dst.x
	dy = src.y - dst.y
	dstBase = Math.sqrt(dx*dx+dy*dy)
	rate = node.h / dstBase
	freq = freq_min + (freq_max - freq_min) * (1 - rate)
	pd_free(freq , duration)
}


if (!String.format) {
  String.format = function(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/{(\d+)}/g, function(match, number) { 
      return typeof args[number] != 'undefined'
        ? args[number] 
        : match
      ;
    });
  };
}


var canvas = document.getElementById("canvas")
var ctx = canvas.getContext("2d");

var AUTO_PLAY = true

var funnyTalkingRate = 0.3

var timeSlider = document.getElementById("timeSlider")

var margin = 2
var cellSize = 0
var gridHeight = null
var gridWidth = null

var weight = 10 // 100000000
var cstcost = 1
var aiWords = ""
var aiFunnyWords = null

var src = null
var dst = null

var heads = []
var head = null
var neighbors = []
var neighbor = null
var candidates = []
var current = null
var path = []
var path_index = 0
var subject = null
var total_paths = 0

var timer = null

var graph = []

function cancelPathFinding()
{

	src = null
	dst = null

	heads = []
	head = null
	neighbors = []
	neighbor = null
	candidates = []
	current = null
	path = []
	path_index = 0
	subject = null
	
	for (var i=0 ; i<gridHeight ; i++)
	{
		for(var j=0 ; j<gridWidth ; j++)
		{
			n = node(j,i)
			n.parent = null
			n.complete = false
			n.visited = false
			n.from = null
			n.path = false
			n.head = false
		}
	}
	if(timer != null)
    {
    	window.clearTimeout(timer)
    	timer = null
    	playing = false
    }	
}


function createGraph()
{
	graph = []
	for (var i=0 ; i<gridHeight ; i++)
	{
		for(var j=0 ; j<gridWidth ; j++)
		{
			id = i*gridWidth + j
			zmin=0.2
			zmax=0.5
			z = Math.random()
			if(z < zmin) z = 0
			else if(z > zmax) z = 1
			else z = (z-zmin+0.5)/(zmax-zmin+0.5)
			graph.push({id: id, x: j, y: i, z: z, visited: false, head: false, complete: false, parent: null, path: false, path_amount: 0})
		}
	}
}


canvas.addEventListener("mousewheel", mouseWheelHandler, false);

var ofx=0
var ofy=0

var orig = null

function zoom(ox, oy, rate)
{
	sx = (ox - ofx) / cellSize
	sy = (oy - ofy) / cellSize
	ofx += sx * cellSize
	ofy += sy * cellSize
	cellSize *= rate
	ofx -= sx * cellSize
	ofy -= sy * cellSize
}

function mouseWheelHandler(e)
{
	zoom(e.x, e.y, e.wheelDeltaY < 0 ? 0.5 : 2.0)
	drawStuff();
}

function canvasDrag(e)
{
	if(e.which != 0)
	{
		dragging = true
		switch(e.which)
		{
		case 1:
			// left click
			ofx+=e.x-p.x
			ofy+=e.y-p.y
			break;
		case 2:
			// middle click
		case 3:
			// right click
			dif = p.y - e.y
			zoom(orig.x, orig.y, dif<0 ? 1.01 : 0.99)
		}
		drawStuff();
	}
	p = {x: e.x, y:e.y}
	
}
var p = {}

document.addEventListener("contextmenu", function(e){
    e.preventDefault();
}, false);

window.addEventListener('resize', resizeCanvas, false);

canvas.addEventListener('click', clickCanvas);

function mouseDownCanvas(e) {
	dragging = false
	orig = {x: e.x, y:e.y}
}
canvas.addEventListener('mousedown', mouseDownCanvas);

var dragging = false;

function clickCanvas(e) {
	if(dragging)
	{
		dragging = false
		return
	}
	y = Math.floor((e.y - ofy) / cellSize)
	x = Math.floor((e.x - ofx) / cellSize)
	id = y * gridWidth + x
	// graph[id].z = 0
	if (src == null) {
		src = node(x,y)
		src.cost = 0
	}
	else if (dst == null) { 
		dst = node(x,y)
		heads.push(src)
		head = src
		timer = window.setTimeout(startASTAR, 1000)
	}
	else{
		cancelPathFinding()
		dst = node(x,y)
		heads = [src]
		head = src
		timer = window.setTimeout(startASTAR, 1000)
	}
	drawStuff();
	p = {x: e.x, y:e.y}
}

function node(x,y)
{
	return graph[y*gridWidth+x]
}

var playing = false

function init()
{
	cancelPathFinding()
	possibles = []
	for (var i=0 ; i<gridHeight ; i++)
	{
		for(var j=0 ; j<gridWidth ; j++)
		{
			n = node(j,i)
			if(n.z == 1)
			{
				possibles.push(n)
			}
		}
	}
	src = possibles[Math.floor(Math.random() * possibles.length)]
	src.cost = 0
	dst = possibles[Math.floor(Math.random() * possibles.length)]
	heads.push(src)
	head = src
	timer = window.setTimeout(startASTAR, 1000)
	playing = true
}

var evaluateDistance


function startASTAR()
{
	evaluateDistance = false
	subject = null
	if (neighbors.length > 0)
	{
		neighbor = neighbors.pop()

		if(neighbor.z == 0)
		{
			aiWords = String.format("I can't go there, it's an obstacle.")
			subject = neighbor
			pd_free(70, 500)
		}
		else if(neighbor.complete)
		{
			aiWords = String.format("I already know a good path to this one, It can't be better from here.")
			subject = neighbor
			// No sound here it's fine ! pd_free(70, 500)
		}
		else 
		{
			if(!neighbor.visited) candidates.push(neighbor)
			neighbor.head = true
			if (neighbor.visited)
			{
				newcost = neighbor.from.cost + cstcost + Math.abs(neighbor.from.z - neighbor.z) * weight
				if(newcost < neighbor.cost)
				{
					neighbor.parent = neighbor.from
					neighbor.cost = newcost
					neighbor.dist = neighbor.cost + neighbor.h

					aiWords = String.format("This path seams better from here ... I reevaluate it")
					subject = neighbor
				}
				else
				{
					aiWords = String.format("This path doesn't worth it ... I giveup")
					subject = neighbor
				}
			}
			else
			{
				evaluateDistance = true

				neighbor.parent = neighbor.from
				neighbor.cost = neighbor.parent.cost + cstcost + Math.abs(neighbor.parent.z - neighbor.z) * weight

				dx = neighbor.x - dst.x
				dy = neighbor.y - dst.y
				// neighbor.h = Math.abs(dx) + Math.abs(dy)
				neighbor.h = cstcost * (Math.abs(dx) + Math.abs(dy)) + Math.sqrt(dx*dx+dy*dy); // Math.sqrt(dx*dx+dy*dy)
				neighbor.dist = neighbor.cost + neighbor.h

				aiWords = String.format("This one cost me {0} and is {1} far to target.\nSo path to destination would cost me {2} ...", neighbor.cost.toFixed(2), neighbor.h.toFixed(2), neighbor.dist.toFixed(2))
				subject = neighbor

				neighbor.visited = true
			}

			soundFromDistance(neighbor, 400, 2000, 500)
		}
		neighbor.from = null

	}
	else if(head == null)
	{
		
		neighbor = null
		if (candidates.length > 0)
		{
			pd_event("head");

			candidates.sort(function(a,b){
				return a.dist - b.dist
			})

			head = candidates.shift();
			
			if (head == dst)
			{
				head = null
				candidates = []
				current = dst

				aiWords = String.format("Destination found ! ... Finally !")
			}
			else
			{
				aiWords = String.format("This one seams worth it, let try with it !")
			}
			subject = head

		}
		else if(current)
		{
			aiWords = String.format("Best path lead from here (I just follow direction actually)")
			subject = current

			current.path_amount += 1
			soundFromDistance(current, 1840, 4240, 100)
			// pd_event("path");
			path.unshift(current)
			current.path = true
			current = current.parent
			if(current == null){
				total_paths += 1
				drawStuff()
				init()
				return
			}
		}
		else
		{
			subject = head
			aiWords = String.format("Ooops, I can't reach destination obviously !")

			head = null
			pd_event("dead");
			init()
			return;			
		}
	}
	else
	{
		pd_event("check");
		
		var adj
		if(head.x>0)
		{
			adj=node(head.x-1,head.y)
			adj.from = head
			neighbors.push(adj)
		}
		if(head.y>0)
		{
			adj=node(head.x,head.y-1)
			adj.from = head
			neighbors.push(adj)
		}
		if(head.x<gridWidth-1)
		{
			adj=node(head.x+1,head.y)
			adj.from = head
			neighbors.push(adj)
		}
		if(head.y<gridHeight-1)
		{
			adj=node(head.x,head.y+1)
			adj.from = head
			neighbors.push(adj)
		}
		head.complete = true

		subject = head
		aiWords = String.format("Let explore neighborhood !")

		head = null
	}

	if(optAIFunnyTalkings && Math.random() < funnyTalkingRate)
	{
		aiFunnyWords = AIThoughts[Math.floor(Math.random() * AIThoughts.length)]
	}
	else
	{
		aiFunnyWords = null
	}

	drawStuff()

	if(optAutoStepping)
	{
		timer = window.setTimeout(startASTAR, 1000.0 / timeSlider.value)
	}
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    cellSize = Math.min(canvas.width / gridWidth, canvas.height / gridHeight)
    /**
     * Your drawings need to be inside this function otherwise they will be reset when 
     * you resize the browser window and the canvas goes will be cleared.
     */
    drawStuff(); 
}





function drawStuff() {
     
     if(src != null && dst != null)
     {
     	dx = src.x - dst.x
		dy = src.y - dst.y
		dstBase = Math.sqrt(dx*dx+dy*dy) 
     }
     else
     {
		dstBase = gridWidth + gridHeight
     }
	



	ctx.fillStyle = "rgb(0,0,0)";
	ctx.setTransform(1,0,0,1,0,0);
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.setTransform(1,0,0,1,ofx,ofy);



	ctx.fillStyle = "rgb(40,40,40)";

	for (var i=0 ; i<gridHeight ; i++)
	{
		for(var j=0 ; j<gridWidth ; j++)
		{
			n = node(j,i)
			id = i*gridWidth + j
			l = Math.floor(n.z * 256)
			
			ctx.fillStyle = "rgb("+l+","+l+","+l+")";
			ctx.fillRect (j*cellSize + margin/2, i*cellSize + margin/2, cellSize-margin, cellSize-margin);
			if(optPathPersistence && n.path_amount > 0)
			{
				pm = n.path_amount / (1 + total_paths)
				ctx.fillStyle = "rgba(255,127,0," + pm + ")";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize / 3,0,2*Math.PI)
				ctx.fill()
			}
			if(n.path)
			{
				ctx.fillStyle = "rgb(255,127,0)";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize / 4,0,2*Math.PI)
				ctx.fill()
			}
			else if(n == dst)
			{
				ctx.fillStyle = "rgb(255,0,0)";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize / 4,0,2*Math.PI)
				ctx.fill()
			}
			else if(head && n.id == head.id)
			{
				ctx.fillStyle = "rgb(255,255,0)";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize / 4,0,2*Math.PI)
				ctx.fill()

			}
			else if(neighbor && n.id == neighbor.id)
			{
				radius = 0.25
				ctx.fillStyle = "rgb(255,255,0)";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize * radius,0,2*Math.PI)
				ctx.fill()

				
			}
			else if(n.complete)
			{
				radius = 0.25
				ctx.fillStyle = "rgb(0,120,200)";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize * radius,0,2*Math.PI)
				ctx.fill()
			}
			else if(n.head)
			{
				radius = 0.15
				ctx.fillStyle = "rgb(64,200,255)";
				ctx.beginPath()
				ctx.arc((j+0.5)*cellSize, (i+0.5)*cellSize, cellSize * radius,0,2*Math.PI)
				ctx.fill()
			}

			if(optShowDistance)
			{
				var text = null
				var size = 0
				var color = "white"
				if(n == neighbor || n == head)
				{
					// disable drawing here
				}			
				else if(n.complete)
				{
					size = 0.20
					text = "" + n.cost.toFixed(2)
				}
				else if(n.head)
				{
					size = 0.12
					text = "" + n.dist.toFixed(2)
				}

				if(text != null)
				{
					measures = ctx.measureText(text)

					scale = cellSize * size / measures.width

					ctx.save();
					ctx.fillStyle = color
					ctx.font="20px Verdana";
					ctx.translate((j+0.5)*cellSize, (i+0.5)*cellSize);
					ctx.scale(scale, scale);
					
					ctx.textAlign = "center";
					ctx.fillText(text, 0, 7);
					ctx.restore();

				}
			}
		}
	}

	for (var i=0 ; i<gridHeight ; i++)
	{
		for(var j=0 ; j<gridWidth ; j++)
		{
			n = node(j,i)

			if (n == src || n == dst)
			{
				ctx.strokeStyle = n == src ? "rgb(0,0,255)" : "rgb(255,0,0)";
				ctx.lineWidth = 2;
				ctx.beginPath()
				ctx.arc((n.x+0.5)*cellSize, (n.y+0.5)*cellSize, cellSize / 3,0,2*Math.PI)
				ctx.stroke()
			}
			if (n == current)
			{
				ctx.strokeStyle = "rgb(255,0,255)";
				ctx.lineWidth = 2;
				ctx.beginPath()
				ctx.arc((n.x+0.5)*cellSize, (n.y+0.5)*cellSize, cellSize / 3,0,2*Math.PI)
				ctx.stroke()
			}

			if(n.from)
			{

			}
			if(n.parent)
			{
				var scale = 0.1
				var lscale = 3
				var dx = (n.x - n.parent.x) * scale
				var dy = (n.y - n.parent.y) * scale

				var from1 = {x: (n.x+dy+0.5-dx*lscale)*cellSize, y: (n.y+dx+0.5-dy*lscale)*cellSize}
				var from2 = {x: (n.x-dy+0.5-dx*lscale)*cellSize, y: (n.y-dx+0.5-dy*lscale)*cellSize}
				var to    = {x: (n.parent.x+0.5+dx*lscale)*cellSize, y: (n.parent.y+0.5+dy*lscale)*cellSize}

				ctx.fillStyle = "rgb(50,250,190)";
				
				ctx.beginPath();
				ctx.moveTo(to.x, to.y);
				ctx.lineTo(from1.x, from1.y);
				ctx.lineTo(from2.x, from2.y);
				ctx.fill();
			}
		}
	}
	if(neighbor && evaluateDistance)
	{
		var from = {x: (neighbor.x+0.5)*cellSize, y: (neighbor.y+0.5)*cellSize}
		var to   = {x: (dst.x+0.5)*cellSize,      y: (dst.y+0.5)*cellSize}
		var grad= ctx.createLinearGradient(from.x, from.y, to.x, to.y);
		grad.addColorStop(0, "yellow");
		grad.addColorStop(1, "red");

		ctx.strokeStyle = grad;
		ctx.lineWidth = 5;
		
		ctx.beginPath();
		ctx.moveTo(from.x, from.y);
		ctx.lineTo(to.x, to.y);
		ctx.stroke();

		if(optShowDistance)
		{
			var left, right;
			if(from.x < to.x)
			{
				left = from
				right = to 
			}
			else
			{
				left = to 
				right = from
			}
			dx = right.x-left.x
			dy = right.y-left.y
			angle = Math.atan2(dy, dx)
			l = Math.sqrt(dx*dx+dy*dy)


			ctx.save();
			ctx.fillStyle = "orange" // ctx.createLinearGradient(0, 0, l, 0);
			ctx.font="20px Verdana";
			ctx.translate(left.x, left.y);
			ctx.rotate(angle);
			
			ctx.textAlign = "center";
			ctx.fillText(String.format("{0}m", neighbor.h.toFixed(2)), l/2, -5);
			ctx.restore();
		}
	}
	if(optAITalkings && subject && aiWords != "")
	{
		padding = 4
		textHeight = 10

    	ctx.font="10px Verdana";
    	
    	measures = ctx.measureText(aiWords)

		box = {
			x: (subject.x + 1.5) * cellSize,
			y: (subject.y - 0.5) * cellSize,
			w: measures.width + 2 * padding,
			h: textHeight + 2 * padding}

		if(aiFunnyWords != null)
		{
			measures = ctx.measureText(aiFunnyWords)
			box.w = Math.max(box.w, measures.width + 2 * padding)
			box.h += textHeight + padding
		}

    	ctx.strokeStyle = "rgb(0,0,0)";
		ctx.lineWidth = 3;
    	ctx.fillStyle = "rgb(255,255,255)";

		ctx.fillRect (box.x, box.y, box.w, box.h);
		ctx.strokeRect (box.x, box.y, box.w, box.h);

		ctx.beginPath();
		ctx.moveTo((subject.x + 0.5) * cellSize, (subject.y + 0.5) * cellSize);
		ctx.lineTo(box.x, box.y + box.h);
		ctx.stroke();

		ctx.fillStyle = "rgb(0,0,0)";
    	ctx.fillText(aiWords,box.x + padding, box.y + padding + textHeight);

    	if(aiFunnyWords != null)
		{
			ctx.font="italic 10px Verdana";
			ctx.fillStyle = "rgb(127,127,127)";
    		ctx.fillText(aiFunnyWords, box.x + padding, box.y + 2 * (padding + textHeight));
		}
	}

}
</script>

</body>


</html>